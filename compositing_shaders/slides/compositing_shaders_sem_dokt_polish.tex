\documentclass{beamer}

\mode<presentation>
{
  \useinnertheme[shadow=true]{rounded} % default from Warsaw theme
  \useoutertheme{split}

  \usecolortheme{orchid} % default from Warsaw theme
  \usecolortheme{whale} % default from Warsaw theme
  \usecolortheme{beaver} % this overrides both orchid and whale, as far as I see, but keep them for safety

  % these override \usecolortheme above
  \setbeamercolor{frametitle}{bg=,fg=darkred!80!black}
  \setbeamercolor{frametitle right}{bg=}

  \usefonttheme[onlylarge]{structurebold}
  \setbeamerfont{block title}{size={}} % default from Warsaw theme
  \setbeamerfont{frametitle}{series=\bfseries} % probably taken care of by structurebold anyway, but keep in case useful for the future

  \setbeamercovered{transparent}
}

\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}

\title{Compositing shaders in X3D\\
Komponowanie shaderów w X3D}

\author[Michalis Kamburelis]{Michalis Kamburelis \\ \texttt{michalis.kambi@gmail.com}}

\pgfdeclareimage[height=2cm]{ii-and-kambivrml}{ii-and-kambivrml}
\logo{\pgfuseimage{ii-and-kambivrml}}

\newcommand*{\codeem}[1]{\textbf{#1}}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Outline}
  \tableofcontents
  % You might wish to add the option [pausesections]
\end{frame}

\section{Wstęp}

\begin{frame}{Wstęp}
Moja praca jest prosta:
  - rozszerzenie 2 zintegrowanych ze sobą języków
  - implementowalne (zrobiona w miesiąc 100% implementacja, z przykładami, dla GLSL)
  Ale nikt inny tego jeszcze nie zrobił :)
  - przynajmniej nie bez wymyślania zupełnie nowego języka; a w tej dziedzinie, nowy język specjalnie do tego problemu -> oznacza że zapewne niewiele osób tego użyje; idea musi być prosta i rozszerzać istniejące języki które *już* są zaimplementowane w rendererach. Dodawanie nowego języka mija się z celem, historia pokazuje że takie języki nie zyskują popularności --- zbyt wąskie zastosowanie, a język w GPU (jak GLSL) zawsze będzie istniał.
  - wyniki bardzo ładne. Będą ładne obrazki.
    Istotnie pozwalam na programowanie i łączenie efektów za pomocą shaderów w bardzo wygodny sposób.
    IMHO dopiero teraz GLSL jest użyteczny dla autorów.
\end{frame}

\section{Co to są shadery, co to jest X3D}

\begin{frame}{X3D}
  VRML/X3D: język do opisu światów 3D.
  TODO: Węzły, pola, przykład.
\end{frame}

\begin{frame}{X3D - język programowania}
Wcale nie taki prosty:
- Jest elegancki mechanizm zdarzeń, za pomocą których można wysyłać i reagować na zdarzenia. Coś jak deklaratywny odpowiednik wywołania metody obiektu. Np. otwórz drzwi kiedy user kliknie na klamkę.
- Są prototypy/external prototypy, za pomocą których można wyrazić nowe węzły. Można zdefiniować część węzłów za pomocą innych węzłów.
Ogólnie "format modeli 3D" to prosta definicja dla użytkowników. Definicja dla nas to "całkiem ładny deklaratywny język programowania".
- Są węzły Script do integracji z innymi językami, np. JavaScript. U mnie --- z własnym prostym językiem skryptowym oraz ze skompilowanym kodem w ObjectPascalu.
TODO:Więcej nowinek z vrml\_engine\_doc, sekcja "advanced features"?
\end{frame}

\begin{frame}{Shadery}
Shadery: języki programowania na GPU. GLSL, Cg, HLSL. To są języki specjalnie do programowania grafiki 3D. Chociaż przy pomocy pewnych sztuczek (tekstury oparte na float, render to textury) można je wykorzystać do ogólnych obliczeń, obecnie do ogólnych obliczeń wygodniejsze są CUDA/OpenCL (google.com/q=gpgpu).

Naturalnie, X3D posiada węzły do definiowania shaderów.

Przykład.
\end{frame}

\begin{frame}{Shadery w X3D}
\end{frame}

\begin{frame}{O shaderach w X3D}
  Existing shader nodes (ComposedShader and such):
    - use the first matching shader
      Good, allows to use various shading languages.
    - can have uniform and attributes values from X3D fields
      Very good (e.g. passing TimeSensor.time to shader is trivial)
    - replace the normal shading
      Good? This directly exposes the GPU (OpenGL, etc.)
        functionality. So --- easy implementation, and following the idea
        of having a specially crafted, optimized shaders for specific
        situations.
      Bad: Unless you are prepared to roll out your own shader generator
        system, this isn't really usable. Before implementing the least
        trivial GLSL effect, you usually want to replicate all the standard
        X3D functionality. Huge task.
\end{frame}

\section{Nasz pomysł}

\begin{frame}{Dlaczego}
Chcelibyśmy intensywnie używać shaderów. Każda właściwość 3D powinna
być programowalna --- po to stworzono shadery.

Ale tradycyjne podejscie, ,,napisz shader który robi wszystko'',
uniemożliwia to. Zaprogramowanie najmniejszej zmiany (np. przefiltruj
światło przez szablon) wymaga reimplementacji skomplikowanego algorytmu naokoło.
% (chociażby równania oświetlenia, ale
\end{frame}

\begin{frame}{Rozwiązanie}

Pozwól programować efekty które modyfikują istniejące zachowanie.
Idea: bardzo prosty w użyciu mechanizm do definiowania nowych,
i używania istniejących, ,,gniazd'' (plugs) --- miejsc gdzie można
dodać kod.

  So
  - You still have the full power of shading language like GLSL
    (we do not hide it from you, we do not invent any new language
    for writing shaders, and implementation doesn't have to do any
    difficult operations to process your shading language code).
  - You can jump straight into the implementation of your
    interesting effect in shading language.
    Mark when it should be used... and you're done.
  - Your effects are immediately reusable: they work under all
    lighting / (multi-)texturing conditions, because the browser
    takes care of it.

  More:
  - Browser implementation can also use this,
    to apply some internal effects this way. So we can have a base
    shader, then a really easy (and separate from the rest)
    implementation of stuff like fog, bump mapping and shadow mapping.
  - Various author effects also instantly cooperate with each other.
\end{frame}

\begin{frame}{Przykłady na start}
  Show examples:
    Shinto shrine: bump mapping, and 2 x shadow maps.
      Each shadow map correctly scales appropriate light source.
      Browser implementation is easy!
      (Show EnableBumpMapping, or maybe EnableFog source)
    Water: 2 separate effects, cooperating with standard browser per-pixel lighting
    Volumetric fog. Turn on/off fog.
    fresnel\_and\_toon: show the X3D source:
      I can just say: "this is a list of effects you should use:
      this one, and this one. Now make it happen."
      And both effects are applied.
\end{frame}

\begin{frame}{Węzły efektów}
  Effects at Apperance.effects:
  - Introducing Effect, EffectPart nodes.
  - We steal ideas from ComposedShader and such: uniform values
    can be trivially declared inside Effect (multiple Effects sum their
    uniforms).
  - Effect code is not complete: it will be plugged into full shader.
    Magic PLUG\_xxx function names are used for this.
\end{frame}

\begin{frame}{Efekty dla źródeł światła}
  Effects at light sources:
\end{frame}

\begin{frame}{Efekty tekstur}
  Effects at textures:
\end{frame}

\begin{frame}{Procedurable tekstury na GPU}
  ShaderTexture:
\end{frame}

\begin{frame}{Efekty działające na grupę}
  Effects at grouping nodes:
\end{frame}

\begin{frame}{Definiuj własne plugs}
  Defining plugs:
  - Effect code may define plugs for following effects to use.
    Trivially easy, just a magic /* PLUG: ... */ comment.
  - You can even still define your own basic shader (like ComposedShader),
    and if you define standard plug names there --- it will work
    with effects. And you can define more of your own plugs,
    for your effects.
\end{frame}

\end{document}
