{ -*- compile-command: "make" -*- }
{
  Copyright 2010-2011 Michalis Kamburelis.

  This file is part of "Kambi VRML game engine".

  "Kambi VRML game engine" is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  "Kambi VRML game engine" is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with "Kambi VRML game engine"; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

  ----------------------------------------------------------------------------
}

uses SysUtils, KambiUtils, KambiClassUtils, VRMLNodes, Object3DAsVRML,
  KambiStringUtils, VRMLFields, VRMLErrors, VRMLShadowMaps;

const
  ShadowMapSize = 1024;

procedure ForceSaveAsX3D(Model: TVRMLNode);
begin
  { TODO: when Model is not TVRMLRootNode_2, wrap it inside new
    TVRMLRootNode_2. Don't assume Model always is TVRMLRootNode_2.
    (For now, LoadVRML on VRML 97 file always produces file when it's true,
    so no need.) }
  (Model as TVRMLRootNode_2).ForceSaveAsX3D;
end;

{ Find Blender's light with given name, and add X3D fields setting
  projection near/far for shadow maps. }
procedure SetLightProjection(Model: TVRMLNode;
  const LightName: string;
  const ProjectionNear, ProjectionFar: Single;
  out L: TNodeX3DLightNode);
var
  SM: TNodeGeneratedShadowMap;
begin
  L := Model.FindNodeByName(TNodeX3DLightNode, LightName, false)
    as TNodeX3DLightNode;
  L.FdProjectionNear.Value := ProjectionNear;
  L.FdProjectionFar.Value := ProjectionFar;

  { add defaultShadowMap, to set size to ShadowMapSize }
  SM := TNodeGeneratedShadowMap.Create('', '');
  L.FdDefaultShadowMap.Value := SM;
  SM.FdUpdate.Value := 'ALWAYS';
  SM.FdSize.Value := ShadowMapSize;
end;

{ Find the given Blender mesh, and set corresponding VRML Shapes
  to receive shadows from the given light. }
procedure MakeShadowMapReceiver(Model: TVRMLNode;
  const MeshName: string; Light: TNodeX3DLightNode);
var
  Group: TNodeGroup_2;
  ShapeNum: Integer;
  Shape: TNodeShape;
begin
  Group := Model.TryFindNodeByName(TNodeGroup_2, 'ME_' + MeshName, false)
    as TNodeGroup_2;
  if Group = nil then
    { Retry with MOD_ prefix, exporter adds this to objects with modifiers. }
    Group := Model.TryFindNodeByName(TNodeGroup_2, 'ME_MOD_' + MeshName, false)
      as TNodeGroup_2;
  Check(Group <> nil, 'Cannot find Blender mesh ' + MeshName);

  { Within a single Blender ME_xxx there may be many VRML Shapes,
    when one Blender mesh uses multiple materials. }
  for ShapeNum := 0 to Group.FdChildren.Count - 1 do
  begin
    Shape := Group.FdChildren.Items[ShapeNum] as TNodeShape;

    { make sure Shape has some (valid) Appearance }
    if Shape.Appearance = nil then
      Shape.Appearance := TNodeAppearance.Create('', '');

    Shape.Appearance.FdReceiveShadows.Add(Light);
  end;
end;

var
  FileName: string;
  Model: TVRMLNode;
  Light: TNodeX3DLightNode;
begin
  Parameters.CheckHigh(1);
  FileName := Parameters[1];

  VRMLWarning := @VRMLWarning_Write;

  Model := LoadVRML(FileName);
  try
    ForceSaveAsX3D(Model);

    SetLightProjection(Model, 'Lamp_001', 8, 31, Light);
//    SetLightProjection(Model, 'Lamp', 10, 34, Light);
//    SetLightProjection(Model, 'Lamp_002', 8, 90, Light);
    MakeShadowMapReceiver(Model, 'Plane', Light);
    MakeShadowMapReceiver(Model, 'Plane_002', Light);
    MakeShadowMapReceiver(Model, 'wall1', Light);
    MakeShadowMapReceiver(Model, 'Tube_002', Light);
    MakeShadowMapReceiver(Model, 'oak_004', Light);

    { For visualizing shadow map depths, it's looks best to put shadow map
      on pretty much everything. }
    //   MakeShadowMapReceiver(Model, 'wall1_004', Light);
    //   MakeShadowMapReceiver(Model, 'wall1_003', Light);
    //   MakeShadowMapReceiver(Model, 'wall1_002', Light);
    //   MakeShadowMapReceiver(Model, 'wall1_001', Light);
    //   MakeShadowMapReceiver(Model, 'oak', Light); {< oak leaves }

    SaveVRMLClassic(Model, StdOutStream, 'Generated by sunny_street_process');
  finally FreeAndNil(Model) end;
end.
