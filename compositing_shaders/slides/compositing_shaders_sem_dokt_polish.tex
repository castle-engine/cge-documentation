\documentclass{beamer}

\mode<presentation>
{
  \useinnertheme[shadow=true]{rounded} % default from Warsaw theme
  \useoutertheme{split}

  \usecolortheme{orchid} % default from Warsaw theme
  \usecolortheme{whale} % default from Warsaw theme
  \usecolortheme{beaver} % this overrides both orchid and whale, as far as I see, but keep them for safety

  % these override \usecolortheme above
  \setbeamercolor{frametitle}{bg=,fg=darkred!80!black}
  \setbeamercolor{frametitle right}{bg=}

  \usefonttheme[onlylarge]{structurebold}
  \setbeamerfont{block title}{size={}} % default from Warsaw theme
  \setbeamerfont{frametitle}{series=\bfseries} % probably taken care of by structurebold anyway, but keep in case useful for the future

  \setbeamercovered{transparent}
}

\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}

\title{Komponowanie shaderów w X3D}

\author[Michalis Kamburelis]{Michalis Kamburelis \\ \texttt{michalis.kambi@gmail.com}}

\pgfdeclareimage[height=2cm]{ii-and-kambivrml}{ii-and-kambivrml}
\logo{\pgfuseimage{ii-and-kambivrml}}

\newcommand*{\codeem}[1]{\textbf{#1}}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Outline}
  \tableofcontents
  % You might wish to add the option [pausesections]
\end{frame}

\section{Wstęp}

\begin{frame}{Wstęp}
Pokazaliśmy jak elegancko i łatwo tworzyć i łączyć efekty graficzne
oparte na shaderach.

\begin{itemize}
  \item Rozszerzenie dwóch zintegrowanych ze sobą języków (X3D i GLSL).
  \item Faktycznie wykonalne (działająca implementacja i przykłady w ~miesiąc).
\end{itemize}

Proste, ale nikt inny tego jeszcze nie zrobił :)

\begin{itemize}
  \item Przynajmniej nie bez wymyślania zupełnie nowego języka pisania shaderów
    (AnySL, Spark, Sh). Ale nowe języki nie zdobywają popularności,
    bo zazwyczaj wymagają przepisania całego renderowania.
    Nasz pomysł to eleganckie rozszerzenie GLSL  i X3D.
    % glsl - (który jest podstawą OpenGL, więc znają go wszyscy
  \item Wyniki bardzo obiecujące. Będą ładne obrazki.
    Różne (poprzednio nietrywialnych) algorytmy na shaderach stają się
    trywialne.
    % Istotnie pozwalam na programowanie i łączenie efektów
    % za pomocą shaderów w bardzo wygodny sposób.
    %  IMHO dopiero teraz GLSL jest użyteczny dla autorów.
\end{itemize}
\end{frame}

\section{Co to jest X3D, co to są shadery}

\begin{frame}{X3D}

\begin{itemize}
  \item X3D to język do opisu światów 3D.
  \item Otwarty, popularny standard.
  \item Proste rzeczy są proste.
  \item Drzewo węzłów w prostych przypadkach (de facto, skierowany graf
    --- mogą być cykle).
  \item Każdy węzeł ma pola i dzieci.
\end{itemize}

Przykład:

\begin{semiverbatim}
\#X3D V3.2 utf8
PROFILE Interchange
Shape \{
  geometry Sphere \{ radius 2 \}
\}
\end{semiverbatim}

Albo (pomijam XMLowe deklaracje):

\begin{semiverbatim}
...
<X3D version="3.2" profile="Interchange" ...>
  <Scene>
    <Shape>
      <Sphere radius="2" />
    </Shape>
  </Scene>
</X3D>
\end{semiverbatim}

\end{frame}

\begin{frame}{X3D jako język programowania}

Kilka ciekawostek które czynią X3D bardziej interesującym:

\begin{itemize}
  \item DEF/USE: referencje, dla wszystkich węzłów.
  \item Mechanizm zdarzeń: wysyłanie i reagowane na zdarzenia.
    Deklaratywny odpowiednik wywołania metody obiektu.
    Np. otwórz drzwi kiedy user kliknie na klamkę.
  \item Prototypy: można definiować nowe, pełnowartościowe,
    węzły jako kombinację istniejących.
  \item Ogólnie "format modeli 3D" to prosta definicja dla użytkowników.
    Definicja dla nas to "całkiem ładny deklaratywny język programowania",
    który akurat ma mnóstwo wbudowanych węzłów na grafiki 3D.
  \item Script: integracja z innymi językami (np. JavaScript) naturalnie łatwa.
     %  np. JavaScript. U mnie --- z własnym prostym językiem skryptowym
     % oraz ze skompilowanym kodem w ObjectPascalu.
     % Więcej nowinek w vrml\_engine\_doc, sekcja "advanced features".
\end{itemize}
\end{frame}

\begin{frame}{Shadery}
Shadery:
\begin{itemize}
  \item Języki do cieniowania obiektów 3D. Uproszczenie: zrób coś per-vertex,
    rasteryzuj, zrób coś per-pixel.
    % Chociaż przy pomocy pewnych sztuczek (tekstury oparte na float,
    % render to textury) można je wykorzystać do ogólnych obliczeń,
    % obecnie do ogólnych obliczeń wygodniejsze są CUDA/OpenCL
    % (google.com/q=gpgpu).
    % Można próbować
    % geom shader
  \item Nas interesują shadery na GPU, czyli do renderowania w czasie
    rzeczywistym. GLSL (OpenGL), Cg (NVidia -> OpenGL lub Direct 3D),
    HLSL (Direct 3D).
  \item Naturalnie, X3D posiada węzły do definiowania shaderów.
\end{itemize}
\end{frame}

\begin{frame}{Shadery w X3D - przykład}
\begin{semiverbatim}
\#X3D V3.2 utf8
PROFILE Interchange
Shape \{
  appearance Appearance \{ shaders ComposedShader \{
    language "GLSL"
    parts [
      ShaderPart \{ type "FRAGMENT"
        url "data:text/plain,
        void main(void)
        \{
          gl\_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        \}" \}
    ]
  \} \}
  geometry Sphere \{ radius 2 \}
\}
\end{semiverbatim}
\end{frame}

\begin{frame}{O shaderach w X3D}

Co złego, co dobrego w shaderach w X3D?

\begin{itemize}
  \item + Wybierz pierwszy obsługiwany shader.
  \item + Można łatwo przekazać do shadera wartości uniform (per-object)
    albo attribute (per-vertex).\\
    Np. przekaż aktualny czas (\texttt{TimeSensor.time} w X3D) to shadera trywialnie.
  \item Shader zastępuje domyślne obliczenia:
    \begin{itemize}
      \item + Łatwe do implementacji, bo właśnie tak działa GPU, na to pozwala
        OpenGL etc.
      \item - \textbf{Trudne} implementowanie własnych shaderów.
        Zanim zaczniesz pisać swój efekt, najpierw odtwórz algorytm
        standardowego renderowania. Głupie, bo renderer umie go wygenerować.
        Możesz go skopiować i zorientować się gdzie dodać kod, ale...
      \item - \textbf{Powstają shadery 1-razowego użytku}.
        Konkretny kod shadera przywiązuje Cię do wielu ustawień sceny
        (ile, jakie tekstury, światła etc.).
        Ogólny shader (uwzględniający wszystkie możliwości) nie jest możliwy,
        bo nie ma szans działać w rozsądnycm czasie.
      \item - \textbf{Wszystkie efekty w jednym worku}.
        Usuwanie / dodawanie efektu oznacza wstawianie kodu do istniejącego
        dużego shadera.
    \end{itemize}
\end{itemize}
\end{frame}

\section{Nasz pomysł}

\begin{frame}{Dlaczego}
Chcelibyśmy intensywnie używać shaderów. Każda właściwość 3D powinna
być programowalna --- po to stworzono shadery.

Ale tradycyjne podejscie, ,,napisz shader który robi wszystko'',
uniemożliwia to. Zaprogramowanie najmniejszej zmiany (np. przefiltruj
światło przez szablon) wymaga reimplementacji skomplikowanego algorytmu naokoło.
\end{frame}

\begin{frame}{Rozwiązanie}

Pozwól programować efekty które modyfikują istniejące zachowanie.
Idea: bardzo prosty w użyciu mechanizm do definiowania nowych,
i używania istniejących, ,,gniazd'' (plugs) --- miejsc gdzie można
dodać kod.

  So
  - You still have the full power of shading language like GLSL
    (we do not hide it from you, we do not invent any new language
    for writing shaders, and implementation doesn't have to do any
    difficult operations to process your shading language code).
  - You can jump straight into the implementation of your
    interesting effect in shading language.
    Mark when it should be used... and you're done.
  - Your effects are immediately reusable: they work under all
    lighting / (multi-)texturing conditions, because the browser
    takes care of it.

  More:
  - Browser implementation can also use this,
    to apply some internal effects this way. So we can have a base
    shader, then a really easy (and separate from the rest)
    implementation of stuff like fog, bump mapping and shadow mapping.
  - Various author effects also instantly cooperate with each other.
\end{frame}

\begin{frame}{Przykłady na start}
  Show examples:
    Shinto shrine: bump mapping, and 2 x shadow maps.
      Each shadow map correctly scales appropriate light source.
      Browser implementation is easy!
      (Show EnableBumpMapping, or maybe EnableFog source)
    Water: 2 separate effects, cooperating with standard browser per-pixel lighting
    Volumetric fog. Turn on/off fog.
    fresnel\_and\_toon: show the X3D source:
      I can just say: "this is a list of effects you should use:
      this one, and this one. Now make it happen."
      And both effects are applied.
\end{frame}

\begin{frame}{Węzły efektów}
  Effects at Apperance.effects:
  - Introducing Effect, EffectPart nodes.
  - We steal ideas from ComposedShader and such: uniform values
    can be trivially declared inside Effect (multiple Effects sum their
    uniforms).
  - Effect code is not complete: it will be plugged into full shader.
    Magic PLUG\_xxx function names are used for this.
\end{frame}

\begin{frame}{Efekty dla źródeł światła}
  Effects at light sources:
\end{frame}

\begin{frame}{Efekty tekstur}
  Effects at textures:
\end{frame}

\begin{frame}{Procedurable tekstury na GPU}
  ShaderTexture:
\end{frame}

\begin{frame}{Efekty działające na grupę}
  Effects at grouping nodes:
\end{frame}

\begin{frame}{Popularne efekty stają się łatwe}
W podobny sposób można zaimplementować typowo wewnętrzne efekty
renderera: shadow maps (filtruj odpowiednie źródło światła),
bump mapping (zmien wektor normalny na podstawie tekstury).
\end{frame}

\begin{frame}{Definiuj własne plugs}
  Defining plugs:
  - Effect code may define plugs for following effects to use.
    Trivially easy, just a magic /* PLUG: ... */ comment.
  - You can even still define your own basic shader (like ComposedShader),
    and if you define standard plug names there --- it will work
    with effects. And you can define more of your own plugs,
    for your effects.
\end{frame}

\section{Pytania?}

\begin{frame}[t]

\begin{center}
{\small
Wszystko jest już zaimplementowane, open-source (LGPL), w moim silniku:\\
{\color{blue} \textbf{\texttt{http://vrmlengine.sourceforge.net/}}}\\
Instrukcje jak pobrać i oglądać przykładowe modele dotyczące komponowania
shaderów:\\
{\color{blue} \textbf{\texttt{http://vrmlengine.sourceforge.net/\\
compositing\_shaders.php}}}}
\end{center}

\vspace{0.25in}

\begin{center}
{\Large Dziękuję za uwagę!}
\end{center}

%\vspace{0.1in}

\begin{center}
{\Huge \alert{Pytania?}}
\end{center}

\end{frame}

\end{document}
